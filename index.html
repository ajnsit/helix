<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>Helix by ajnsit</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Helix</h1>
        <h2>Helix - Haskell web framework</h2>

        <section id="downloads">
          <a href="https://github.com/ajnsit/helix/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/ajnsit/helix/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/ajnsit/helix" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h1>
<a id="helix----" class="anchor" href="#helix----" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://ajnsit.github.io/helix">Helix</a> <a href="https://hackage.haskell.org/package/helix"><img src="https://img.shields.io/badge/hackage-v0.9.5-brightgreen.svg" alt="Hackage"></a> <a href="http://packdeps.haskellers.com/feed?needle=helix"><img src="https://img.shields.io/hackage-deps/v/helix.svg" alt="Hackage-Deps"></a> <a href="https://travis-ci.org/ajnsit/helix"><img src="https://img.shields.io/travis/ajnsit/helix.svg" alt="Build Status"></a> <a href="https://gitter.im/ajnsit/helix"><img src="https://img.shields.io/badge/gitter-join%20chat%20%E2%86%A3-blue.svg" alt="Join the chat at https://gitter.im/ajnsit/helix"></a>
</h1>

<p>Helix is a micro web framework for Haskell. It was extracted from <a href="http://hackage.haskell.org/package/wai-routes">Wai Routes</a> and aims to provide functionality beyond simple typesafe URLs.</p>

<p>Helix is based on the Haskell <a href="http://hackage.haskell.org/package/wai">Web Application Interface</a> and uses it for most of the heavy lifting. It also provides a convenient but thin veneer over most of the wai API so it is unnecessary to directly use raw wai APIs when building web apps.</p>

<p>Much of Helix's typesafe URL functionality was pulled from the corresponding features in <a href="http://www.yesodweb.com/">Yesod</a>. Helix however, adds new routing features as well such as the ability to use subsites within route hierarchies.</p>

<h1>
<a id="features" class="anchor" href="#features" aria-hidden="true"><span class="octicon octicon-link"></span></a>Features</h1>

<p>Helix adds the following features on top of wai -</p>

<ul>
<li>Typesafe URLs, including automatic boilerplate generation using TH. Including features such as -

<ul>
<li>Nested Routes</li>
<li>Subsites</li>
<li>Route Annotations</li>
</ul>
</li>
<li>Seamlessly mix and match "unrouted" request handlers with typesafe routing.</li>
<li>Sitewide Master data which is passed to all handlers and can be used for persistent data (like DB connections)</li>
<li>Easy to use Handler Monad which allows direct access to request and master data</li>
<li>Easy composition of multiple routes and middleware to construct an application</li>
<li>Ability to abort processing and pass control to the next application in the wai stack</li>
<li>Streaming responses</li>
</ul>

<h1>
<a id="performance" class="anchor" href="#performance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Performance</h1>

<p>When it comes to performance, Helix compares quite favorably with other Haskell web development micro frameworks.</p>

<p>See more details here - <a href="https://github.com/philopon/apiary-benchmark">philopon/apiary-benchmark</a></p>

<p><img src="./benchmark/result-tama.png" alt="result"></p>

<h1>
<a id="example-usage" class="anchor" href="#example-usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example Usage</h1>

<p>Helix comes with several examples in the <code>examples/</code> directory. New examples are being added regularly.</p>

<p><strong>Example 1. Hello World</strong> - <a href="https://github.com/ajnsit/helix/tree/master/examples/hello-world/src">Code</a></p>

<p>A simple hello-world web app with two interlinked pages. This provides the simplest example of using routing and linking between pages with typesafe routes.</p>

<p><strong>Example 2. Hello World with Subsites</strong> - <a href="https://github.com/ajnsit/helix/tree/master/examples/subsites/src">Code</a></p>

<p>Similar functionality as the first example, but uses a hello world subsites to provide the hello world functionality. A subsite is an independently developed site that can be embedded into a parent site as long as the parent site satisfies a particular api contract. It's easy to swap out subsites for different functionality as long as the api contract remains constant.</p>

<p><strong>Example 3. Using Blaze-HTML to generate HTML</strong> - <a href="https://github.com/ajnsit/helix/tree/master/examples/blaze-html/src">Code</a></p>

<p>A simple example of how to generate HTML using blaze-html combinators in your handlers.</p>

<p><strong>Example 4. Using Shakespearean Templates (hamlet, cassius, lucius, julius) to generate HTML/CSS/JS</strong> - <a href="https://github.com/ajnsit/helix/tree/master/examples/shakespeare/src">Code</a></p>

<p>A simple example of how to generate HTML/CSS/JS using shakespearean templates. You can use both external and inline templates.</p>

<p><strong>Example 5. Building a JSON REST Service</strong> - <a href="https://github.com/ajnsit/helix/tree/master/examples/rest-json/src">Code</a></p>

<p>Provides a simple example of how to build JSON REST services with helix. Uses Aeson for JSON conversion. Note that this example just demonstrates the web facing side of the application. It doesn't permanently persist data, and is also not threadsafe. You must use a more robust data storage mechanism in production! An example of doing this with a Relational DB adapter (like persistent) is in the works.</p>

<p><strong>Example 6. Stream a response</strong> - <a href="https://github.com/ajnsit/helix/tree/master/examples/streaming-response/src">Code</a></p>

<p>Wai has had the ability to stream content for a long time. Now helix exposes this functionality with the <code>stream</code> function. This example shows how to stream content in a handler. Note that most browsers using default settings will not show content as it is being streamed. You can use "curl" to observe the effect of streaming. E.g. - <code>curl localhost:8080</code> will dump the data as it is being streamed from the server.</p>

<p><strong>Example 7. Kitchen sink</strong> - <a href="https://github.com/ajnsit/helix/tree/master/examples/kitchen/src">Code</a></p>

<p><em>Work in progress</em>. Demonstrates all major features in helix.</p>

<p><strong>Example 8. Unrouted</strong> - <a href="https://github.com/ajnsit/helix/tree/master/examples/unrouted/src">Code</a></p>

<p>Demonstrates "unrouted" applications. These require no TH, or GHC extensions. Basically allow you to sequence request handlers in a cascade, with each handler having the full functionality of HandlerM monad available to them. Each handler also has access to untyped (but parsed) route information. Unrouted handlers are freely mixable with typesafe routing.</p>

<h1>
<a id="deployment" class="anchor" href="#deployment" aria-hidden="true"><span class="octicon octicon-link"></span></a>Deployment</h1>

<p>The current recommended route (pun not intended) for deploying helix apps is <a href="http://hackage.haskell.org/package/keter">keter</a>. You need to read the port from the environment variables -</p>

<pre><code>-- Run the application
main :: IO ()
main = do
  port' &lt;- getEnv "PORT"
  let port = read port'
  run port $ waiApp application
</code></pre>

<p>Then put something like this in <code>config/keter.yaml</code> -</p>

<pre><code>exec: ../path/to/executable
host: mydomainname.example.com
</code></pre>

<p>Then create a tarball with <code>config/keter.yaml</code>, <code>path/to/executable</code>, and any other files needed at runtime for your application. Rename the tarball to have a <code>.keter</code> extension.</p>

<p>Upload that file to your server's <code>incoming</code> folder for keter to pick it up. You obviously need keter already installed and configured properly at the server.</p>

<h1>
<a id="planned-features" class="anchor" href="#planned-features" aria-hidden="true"><span class="octicon octicon-link"></span></a>Planned Features</h1>

<p>The following features are planned for later releases -</p>

<ul>
<li>Support for raw network responses (see <a href="http://hackage.haskell.org/package/wai-3.0.3.0/docs/Network-Wai.html#v:responseRaw">http://hackage.haskell.org/package/wai-3.0.3.0/docs/Network-Wai.html#v:responseRaw</a>)</li>
<li>Seamless websocket support</li>
<li>Development mode</li>
<li>Scaffolding</li>
<li>Better documentation, and a getting started tutorial</li>
<li>More tests and code coverage</li>
</ul>

<h1>
<a id="changelog" class="anchor" href="#changelog" aria-hidden="true"><span class="octicon octicon-link"></span></a>Changelog</h1>

<ul>
<li>0.9.5 : Subsites now play well with hierarchical routes</li>
<li>0.9.4 : Wai-3.2 compatibility. Added functions to manipulate wai "vault". Minor changes to internal types.</li>
<li>0.9.3 : Added <code>content</code> and <code>whenContent</code>. Allow http-types-0.9.</li>
<li>0.9.2 : Fix failing test in release tarball. (Only tests changed).</li>
<li>0.9.1 : Greatly simplified subsites (simply use mkRouteSub). Added 'mountedAppHandler' to integrate external full wai apps.</li>
<li>0.9.0 : Support for "unrouted" handlers. API changes to avoid returning lazy text or bytestring. Methods to fetch post/file params. Removed 'HandlerMM' and made 'Handler' more useful.</li>
<li>0.8.1 : Bumped dependencies. Added 'HandlerMM' type alias</li>
<li>0.8.0 : Replaced 'show/renderRoute' with 'show/renderRouteSub' and 'show/renderRouteMaster'. Added functions to access request headers (reqHeader/s), send a part of a file (filepart). Auto infer mime-types when sending files. Added cookie handling functions (get/setCookie/s). Added 'sub' to allow access to subsite datatype.</li>
<li>0.7.3 : Added 'stream' to stream responses. Added 'asContent', 'css', and 'javascript' functions.</li>
<li>0.7.2 : Added 'file' to send a raw file directly, 'rawBody' and 'jsonBody' to consume request body. Refactored RouteM to add 'catchAll' and 'waiApp'.</li>
<li>0.7.1 : Added 'showRouteQuery', renamed 'text' to 'plain', 'html' now accepts Text instead of ByteString</li>
<li>0.7.0 : Subsites support added</li>
<li>0.6.2 : Added 'maybeRoute' and 'routeAttrSet', to get information about the currently executing route</li>
<li>0.6.1 : Fixed cabal and travis files</li>
<li>0.6.0 : Removed dependency on yesod-routes. Updated code to compile with wai-3 and ghc-7.8, ghc-7.10</li>
<li>0.5.1 : Bumped dependency upper bounds to allow text 1.*</li>
<li>0.5.0 : Added raw,text,html,json helpers. Update to wai-2.1.</li>
<li>0.4.1 : showRoute now returns "/" instead of ""</li>
<li>0.4.0 : Wai 2 compatibility. Replaced 'liftResourceT' with 'lift'</li>
<li>0.3.4 : Added 'liftResourceT' to lift a ResourceT into HandlerM</li>
<li>0.3.3 : Better exports from the Helix module</li>
<li>0.3.2 : Added HandlerM Monad which makes it easier to build Handlers</li>
<li>0.3.1 : Removed internal 'App' synonym which only muddied the types. Added common content types for convenience.</li>
<li>0.3.0 : yesod-routes 1.2 compatibility. Abstracted request data. Created <code>runNext</code> which skips to the next app in the wai stack</li>
<li>0.2.4 : Put an upper bound on yesod-routes version as 1.2 breaks API compatibility</li>
<li>0.2.3 : Implemented a better showRoute function. Added blaze-builder as a dependency</li>
<li>0.2.2 : Fixed license information in hs and cabal files</li>
<li>0.2.1 : Changed license to MIT</li>
<li>0.2   : Updated functionality based on yesod-routes package</li>
<li>0.1   : Intial release</li>
</ul>
      </section>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-66875415-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
